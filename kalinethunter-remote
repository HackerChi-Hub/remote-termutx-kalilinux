#!/usr/bin/env bash

########################################
#  kalinethunter-remote (LF 版本)
#  Bash-only • 自动检测 CRLF • 颜色提示
########################################
# --- 颜色 ---
red='\033[1;31m'
yellow='\033[1;33m'
blue='\033[1;34m'
reset='\033[0m'

# --- 确保使用 Bash ---
if [ -z "${BASH_VERSION:-}" ]; then
    if command -v bash >/dev/null 2>&1; then
        exec bash "$0" "$@"
    else
        printf '%b[!] 此脚本需要 bash，请先安装 bash。%b\n' "$red" "$reset" >&2
        exit 1
    fi
fi

# --- 检查脚本自身是否含 CRLF ---
guard_lf_endings() {
    if LC_ALL=C grep -q $'\r' "$0"; then
        printf '%b[!] 检测到脚本内含 CR (\\r) 字符，可能由 Windows/CRLF 行尾引入。%b\n' "$red" "$reset" >&2
        printf '%b    解决办法：运行 dos2unix %s 或在编辑器中改为 LF 重新保存。%b\n' "$yellow" "$0" "$reset" >&2
        exit 1
    fi
}
guard_lf_endings

# --- 安全选项 ---
if ! set -euo pipefail 2>/dev/null; then
    set -eu
    printf '%b[i] 当前 shell 不支持 pipefail，已降级为 set -eu。%b\n' "$yellow" "$reset" >&2
fi

SCRIPT_NAME="$(basename "$0")"

### 全局常量 ###
DEFAULT_VNC_DISPLAY="${VNC_DISPLAY:-:1}"
DEFAULT_VNC_GEOMETRY="${VNC_GEOMETRY:-1280x720}"
DEFAULT_VNC_DEPTH="${VNC_DEPTH:-24}"
CN_MIRROR_HOST="mirrors.tuna.tsinghua.edu.cn"

BACKUP_BASE="/var/backups/xfce-remote-setup"
RUN_ID="$(date +%Y%m%d-%H%M%S)"
BACKUP_ROOT=""
MANIFEST=""
ACTION=""
RESTORE_ID=""

usage() {
    cat <<EOF
脚本会在运行时提供菜单，可选择：
  1) 安装/配置 XFCE + VNC/XRDP（自动切换清华源）
  2) 恢复到最近一次备份
  3) 恢复到指定备份批次
  4) 退出

备份目录：${BACKUP_BASE}/<RUN_ID>（会生成 latest 软链接）

运行：sudo ./${SCRIPT_NAME}
EOF
}

need_root() {
    if [[ "$(id -u)" -ne 0 ]]; then
        printf '%b[!] 请使用 sudo 或 root 运行此脚本。%b\n' "$red" "$reset"
        exit 1
    fi
}

select_action() {
    cat <<'EOF'
==============================
  XFCE 远程环境配置脚本
==============================
请选择操作：
  1) 安装/配置（默认使用清华源）
  2) 恢复到最近一次备份
  3) 恢复到指定备份批次
  4) 退出
EOF
    while true; do
        read -rp "输入选项 [1-4]: " choice
        case "$choice" in
            1) ACTION="install"; break ;;
            2) ACTION="restore"; RESTORE_ID="latest"; break ;;
            3)
                ACTION="restore"
                read -rp "请输入备份 RUN_ID（见 ${BACKUP_BASE}/）： " RESTORE_ID
                [[ -z "$RESTORE_ID" ]] && { printf '%b[!] 不能为空。%b\n' "$red" "$reset"; continue; }
                break
                ;;
            4) printf '%b已取消。%b\n' "$blue" "$reset"; exit 0 ;;
            *) printf '%b无效选择，请重新输入。%b\n' "$yellow" "$reset" ;;
        esac
    done
}

detect_user() {
    DESKTOP_USER="${SUDO_USER:-root}"
    DESKTOP_HOME="$(eval echo "~${DESKTOP_USER}")"
    if [[ ! -d "$DESKTOP_HOME" ]]; then
        printf '%b[!] 无法定位用户主目录：%s%b\n' "$red" "$DESKTOP_HOME" "$reset"
        exit 1
    fi
}

init_backup_dir() {
    install -d -m 755 "$BACKUP_BASE"
    BACKUP_ROOT="$BACKUP_BASE/$RUN_ID"
    MANIFEST="$BACKUP_ROOT/manifest.tsv"
    install -d -m 700 "$BACKUP_ROOT"
    : >"$MANIFEST"
}

set_restore_target() {
    if [[ "$RESTORE_ID" == "latest" ]]; then
        if [[ -L "$BACKUP_BASE/latest" || -d "$BACKUP_BASE/latest" ]]; then
            BACKUP_ROOT="$(readlink -f "$BACKUP_BASE/latest")"
        else
            printf '%b[!] 未找到 latest 备份。%b\n' "$red" "$reset"
            exit 1
        fi
    else
        BACKUP_ROOT="$BACKUP_BASE/$RESTORE_ID"
    fi

    if [[ ! -d "$BACKUP_ROOT" ]]; then
        printf '%b[!] 备份目录不存在：%s%b\n' "$red" "$BACKUP_ROOT" "$reset"
        exit 1
    fi
    MANIFEST="$BACKUP_ROOT/manifest.tsv"
    if [[ ! -f "$MANIFEST" ]]; then
        printf '%b[!] 找不到 manifest：%s%b\n' "$red" "$MANIFEST" "$reset"
        exit 1
    fi
}

manifest_has_entry() {
    local target="$1"
    if [[ -f "$MANIFEST" ]]; then
        grep -Fqx -- "$target"$'\tbackup' "$MANIFEST" 2>/dev/null && return 0
        grep -Fqx -- "$target"$'\tabsent' "$MANIFEST" 2>/dev/null && return 0
    fi
    return 1
}

backup_file() {
    local target="$1"
    [[ "$ACTION" == "restore" ]] && return
    manifest_has_entry "$target" && return

    mkdir -p "$BACKUP_ROOT$(dirname "$target")"
    if [[ -e "$target" ]]; then
        cp -a "$target" "$BACKUP_ROOT$target"
        printf '%s\tbackup\n' "$target" >>"$MANIFEST"
    else
        printf '%s\tabsent\n' "$target" >>"$MANIFEST"
    fi
}

restore_changes() {
    printf '%b[i] 正在恢复：%s%b\n' "$blue" "$BACKUP_ROOT" "$reset"
    while IFS=$'\t' read -r target status; do
        [[ -z "$target" ]] && continue
        case "$status" in
            backup)
                if [[ -e "$BACKUP_ROOT$target" ]]; then
                    mkdir -p "$(dirname "$target")"
                    cp -a "$BACKUP_ROOT$target" "$target"
                    printf '%b[✓] 恢复 %s%b\n' "$blue" "$target" "$reset"
                else
                    printf '%b[!] 缺少备份：%s%b\n' "$red" "$BACKUP_ROOT$target" "$reset"
                fi
                ;;
            absent)
                if [[ -e "$target" ]]; then
                    rm -f "$target"
                    printf '%b[✓] 删除新建文件：%s%b\n' "$blue" "$target" "$reset"
                fi
                ;;
            *)
                printf '%b[!] manifest 状态异常：%s %s%b\n' "$red" "$target" "$status" "$reset"
                ;;
        esac
    done <"$MANIFEST"
    printf '%b[✓] 恢复完成。%b\n' "$blue" "$reset"
}

configure_cn_mirror() {
    [[ -r /etc/os-release ]] || { printf '%b[!] 无法读取 /etc/os-release。%b\n' "$red" "$reset"; exit 1; }
    . /etc/os-release
    CODENAME="${UBUNTU_CODENAME:-${VERSION_CODENAME:-}}"
    [[ -n "$CODENAME" ]] || { printf '%b[!] 无法确定系统代号。%b\n' "$red" "$reset"; exit 1; }

    backup_file /etc/apt/sources.list
    touch /etc/apt/sources.list

    case "$ID" in
        ubuntu|linuxmint|elementary|neon)
            MIRROR_PATH="ubuntu"
            COMPONENTS="main restricted universe multiverse"
            cat <<EOF >/etc/apt/sources.list
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME} ${COMPONENTS}
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME}-updates ${COMPONENTS}
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME}-backports ${COMPONENTS}
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME}-security ${COMPONENTS}
EOF
            ;;
        debian)
            MIRROR_PATH="debian"
            COMPONENTS="main contrib non-free non-free-firmware"
            cat <<EOF >/etc/apt/sources.list
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME} ${COMPONENTS}
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME}-updates ${COMPONENTS}
deb https://${CN_MIRROR_HOST}/${MIRROR_PATH} ${CODENAME}-backports ${COMPONENTS}
deb https://${CN_MIRROR_HOST}/debian-security ${CODENAME}-security ${COMPONENTS}
EOF
            ;;
        *)
            printf '%b[!] 暂不支持 ID=%s 自动切换镜像。%b\n' "$yellow" "$ID" "$reset"
            ;;
    esac

    printf '%b[✓] 已切换 APT 源到清华 (%s:%s)。%b\n' "$blue" "$ID" "$CODENAME" "$reset"
}

update_system() {
    printf '%b[i] 更新系统...%b\n' "$blue" "$reset"
    apt update
    DEBIAN_FRONTEND=noninteractive apt full-upgrade -y
}

install_packages() {
    printf '%b[i] 安装 XFCE、字体、VNC/XRDP...%b\n' "$blue" "$reset"
    DEBIAN_FRONTEND=noninteractive apt install -y \
        xfce4 xfce4-goodies dbus-x11 x11-xserver-utils policykit-1 \
        fonts-noto fonts-noto-cjk fonts-noto-color-emoji \
        tigervnc-standalone-server tigervnc-common \
        xrdp xorgxrdp pulseaudio net-tools \
        locales
}

configure_locales() {
    printf '%b[i] 配置 UTF-8 语言环境...%b\n' "$blue" "$reset"
    backup_file /etc/locale.gen
    sed -i 's/^# *\(en_US\.UTF-8 UTF-8\)/\1/' /etc/locale.gen
    grep -q '^zh_CN\.UTF-8 UTF-8' /etc/locale.gen || echo 'zh_CN.UTF-8 UTF-8' >>/etc/locale.gen
    locale-gen en_US.UTF-8 zh_CN.UTF-8
    update-locale LANG=en_US.UTF-8
}

install_input_method() {
    printf '%b[i] 安装 fcitx5...%b\n' "$blue" "$reset"
    DEBIAN_FRONTEND=noninteractive apt install -y \
        fcitx5 fcitx5-data fcitx5-config-qt fcitx5-module-xim \
        fcitx5-chinese-addons \
        fcitx5-frontend-gtk3 fcitx5-frontend-gtk4 \
        fcitx5-frontend-qt5 fcitx5-frontend-qt6
}

setup_input_method_env() {
    printf '%b[i] 写入 fcitx5 环境变量...%b\n' "$blue" "$reset"
    backup_file /etc/profile.d/99-fcitx5.sh
    cat <<'EOF' >/etc/profile.d/99-fcitx5.sh
export GTK_IM_MODULE=fcitx5
export QT_IM_MODULE=fcitx5
export XMODIFIERS="@im=fcitx5"
export DefaultIMModule=fcitx5
export LANG=${LANG:-en_US.UTF-8}
EOF
    chmod 644 /etc/profile.d/99-fcitx5.sh

    install -d -m 700 "$DESKTOP_HOME/.config"
    PROFILE_FILE="$DESKTOP_HOME/.xprofile"
    backup_file "$PROFILE_FILE"
    cat <<'EOF' >"$PROFILE_FILE"
export GTK_IM_MODULE=fcitx5
export QT_IM_MODULE=fcitx5
export XMODIFIERS="@im=fcitx5"
export DefaultIMModule=fcitx5
export LANG=${LANG:-en_US.UTF-8}
EOF
    chown "$DESKTOP_USER":"$DESKTOP_USER" "$PROFILE_FILE"

    AUTOSTART_DIR="$DESKTOP_HOME/.config/autostart"
    install -d -m 700 "$AUTOSTART_DIR"
    backup_file "$AUTOSTART_DIR/fcitx5.desktop"
    cat <<'EOF' >"$AUTOSTART_DIR/fcitx5.desktop"
[Desktop Entry]
Type=Application
Name=Fcitx5
Exec=fcitx5
X-GNOME-Autostart-enabled=true
EOF
    chown -R "$DESKTOP_USER":"$DESKTOP_USER" "$AUTOSTART_DIR"
}

prepare_vnc_xstartup() {
    printf '%b[i] 配置 VNC xstartup...%b\n' "$blue" "$reset"
    install -d -m 700 /etc/skel/.vnc
    backup_file /etc/skel/.vnc/xstartup
    cat <<'EOF' >/etc/skel/.vnc/xstartup
#!/bin/sh
unset SESSION_MANAGER
unset DBUS_SESSION_BUS_ADDRESS
[ -f "$HOME/.xprofile" ] && . "$HOME/.xprofile"
export PULSE_SERVER=unix:/tmp/pulse-native
xrdb "$HOME/.Xresources" 2>/dev/null || true
startxfce4 &
EOF
    chmod +x /etc/skel/.vnc/xstartup

    install -d -m 700 "$DESKTOP_HOME/.vnc"
    backup_file "$DESKTOP_HOME/.vnc/xstartup"
    cp -a /etc/skel/.vnc/xstartup "$DESKTOP_HOME/.vnc/xstartup"
    chown -R "$DESKTOP_USER":"$DESKTOP_USER" "$DESKTOP_HOME/.vnc"
}

configure_xsession() {
    backup_file /etc/skel/.xsession
    cat <<'EOF' >/etc/skel/.xsession
#!/bin/sh
[ -f "$HOME/.xprofile" ] && . "$HOME/.xprofile"
exec startxfce4
EOF
    chmod +x /etc/skel/.xsession

    backup_file "$DESKTOP_HOME/.xsession"
    cp /etc/skel/.xsession "$DESKTOP_HOME/.xsession"
    chown "$DESKTOP_USER":"$DESKTOP_USER" "$DESKTOP_HOME/.xsession"
}

configure_xrdp() {
    printf '%b[i] 配置 XRDP...%b\n' "$blue" "$reset"
    backup_file /etc/xrdp/startwm.sh
    cat <<'EOF' >/etc/xrdp/startwm.sh
#!/bin/sh
[ -f "$HOME/.xprofile" ] && . "$HOME/.xprofile"
export PULSE_SERVER=unix:/tmp/pulse-native
unset DBUS_SESSION_BUS_ADDRESS
unset XDG_RUNTIME_DIR
startxfce4
EOF
    chmod +x /etc/xrdp/startwm.sh
}

create_wrappers() {
    printf '%b[i] 创建 VNC/XRDP 启停脚本...%b\n' "$blue" "$reset"

    backup_file /usr/local/bin/vnc-start
    cat <<EOF >/usr/local/bin/vnc-start
#!/usr/bin/env bash
set -euo pipefail
DISPLAY_NUM="\${VNC_DISPLAY:-$DEFAULT_VNC_DISPLAY}"
GEOMETRY="\${VNC_GEOMETRY:-$DEFAULT_VNC_GEOMETRY}"
DEPTH="\${VNC_DEPTH:-$DEFAULT_VNC_DEPTH}"
PULSE_DIR="/tmp/pulse-\${USER:-\$UID}"

install -d -m 700 "\$PULSE_DIR"

if ! pulseaudio --check 2>/dev/null; then
    pulseaudio --start --exit-idle-time=-1 --system=false \
        --daemonize=true --log-target=file:/tmp/pulseaudio.log \
        --load="module-native-protocol-unix auth-anonymous=1 socket=\$PULSE_DIR/pulse-native" || true
fi

if pgrep -f "Xtigervnc .* \${DISPLAY_NUM}" >/dev/null; then
    echo "[i] VNC 已在 \$DISPLAY_NUM 运行"
    exit 0
fi

vncserver "\$DISPLAY_NUM" -geometry "\$GEOMETRY" -depth "\$DEPTH"
PORT_OFFSET="\${DISPLAY_NUM#:}"
echo "[✓] VNC 运行于 localhost:\$((5900 + PORT_OFFSET))"
EOF

    backup_file /usr/local/bin/vnc-stop
    cat <<'EOF' >/usr/local/bin/vnc-stop
#!/usr/bin/env bash
set -euo pipefail
DISPLAY_NUM="${VNC_DISPLAY:-:1}"
if pgrep -f "Xtigervnc .* ${DISPLAY_NUM}" >/dev/null; then
    vncserver -kill "${DISPLAY_NUM}"
    pkill -f pulseaudio || true
    echo "[✓] 已停止 VNC"
else
    echo "[i] VNC 未运行"
fi
EOF

    backup_file /usr/local/bin/rdp-start
    cat <<'EOF' >/usr/local/bin/rdp-start
#!/usr/bin/env bash
set -euo pipefail
PULSE_DIR="/tmp/pulse-\${USER:-\$UID}"
install -d -m 700 "\$PULSE_DIR"

if ! pulseaudio --check 2>/dev/null; then
    pulseaudio --start --exit-idle-time=-1 --system=false \
        --daemonize=true --log-target=file:/tmp/pulseaudio.log \
        --load="module-native-protocol-unix auth-anonymous=1 socket=\$PULSE_DIR/pulse-native" || true
endifi

if pgrep -x xrdp >/dev/null; then
    echo "[i] XRDP 已运行"
    exit 0
fi

/usr/sbin/xrdp-sesman &
/usr/sbin/xrdp --nodaemon &
echo "[✓] XRDP 运行于 0.0.0.0:3390（建议配合 SSH/ADB 转发）"
EOF

    sed -i 's/endifi/fi/' /usr/local/bin/rdp-start

    backup_file /usr/local/bin/rdp-stop
    cat <<'EOF' >/usr/local/bin/rdp-stop
#!/usr/bin/env bash
set -euo pipefail
pkill -x xrdp || true
pkill -x xrdp-sesman || true
pkill -f pulseaudio || true
echo "[✓] 已停止 XRDP"
EOF

    chmod +x /usr/local/bin/vnc-start /usr/local/bin/vnc-stop \
             /usr/local/bin/rdp-start /usr/local/bin/rdp-stop
}

post_message() {
    ln -sfn "$BACKUP_ROOT" "$BACKUP_BASE/latest"
    cat <<EOF

[完成] XFCE 桌面 + VNC/XRDP + fcitx5 + 清华镜像 配置完成。

备份目录：$BACKUP_ROOT
恢复：
  • 最新：运行脚本 → 选择 “恢复到最近一次备份”
  • 指定：运行脚本 → 选择 “恢复到指定备份” 并输入 RUN_ID

下一步：
  1. 切换到普通用户（当前配置针对：$DESKTOP_USER）。
  2. 首次运行前设置 VNC 密码：vncpasswd
  3. 启动/停止：
       vnc-start    # 默认 localhost:5901
       vnc-stop
       rdp-start    # 监听 0.0.0.0:3390
       rdp-stop
  4. 建议通过 SSH 隧道访问：
       ssh -L 5901:localhost:5901 <device>
       ssh -L 3390:localhost:3390 <device>

中文环境：
  • 已安装 Noto 字体 + zh_CN.UTF-8 locale。
  • fcitx5 托盘图标，Ctrl+Space 切换输入法。

性能提示：
  • 运行 VNC_GEOMETRY=1024x600 vnc-start 可降低资源占用。
  • XFCE → 设置 → 窗口管理器微调 → 关闭合成器 可提速。
  • termux-wake-lock + tmux 防止 Android 后台杀进程。

如需更多定制，欢迎继续提需求。

EOF
}

### 主流程 ###
need_root
guard_lf_endings   # 再次确认（避免在 sudo 重新执行后意外换行）
select_action

if [[ "$ACTION" == "restore" ]]; then
    set_restore_target
    restore_changes
    exit 0
fi

detect_user
init_backup_dir
configure_cn_mirror
update_system
install_packages
configure_locales
install_input_method
setup_input_method_env
prepare_vnc_xstartup
configure_xsession
configure_xrdp
create_wrappers
post_message
